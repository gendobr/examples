# -*- coding: utf-8 -*-
"""owlready2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11M1d8pB0RMCaXhE135AeIKuPp57jlTrW

# Owlready 2 examples

## Support materials for courses "Intelligent Information systems" and "XML technologies" @ Zaporizhzhya National University.

Sample use cases of owlready2 ( https://pythonhosted.org/Owlready2/ , https://buildmedia.readthedocs.org/media/pdf/owlready2/latest/owlready2.pdf ).

Owlready2 is a module for ontology-oriented programming in Python. It can load OWL 2.0 ontologies as Python objects, modify them, save them, and perform reasoning via HermiT (included). Owlready2 allows a transparent access to OWL ontologies (contrary to usual Java-based API).

Owlready version 2 includes an optimized triplestore / quadstore, based on SQLite3. This quadstore is optimized both for performance and memory consumption. Controray to version 1, Owlready2 can deal with big ontologies.

Owlready2 has been created at the LIMICS reseach lab, University Paris 13, Sorbonne Paris Cité, INSERM UMRS 1142, Paris 6 University, by Jean-Baptiste Lamy. It was developed during the VIIIP research project funded by ANSM, the French Drug Agency; this is why some examples in this documentation relate to drug ;).

Owlready2 is available under the GNU LGPL licence v3. A forum/mailing list is available for Owlready on Nabble: http://owlready.8326.n8.nabble.com

## Initial actions

Before we start, we need to install owlready2:
"""

!pip install owlready2

"""Then we import the library"""

from owlready2 import *

"""and load the pizza ontology"""

onto_path.append("/home/cache")
onto = get_ontology("https://raw.githubusercontent.com/owlcs/pizza-ontology/master/pizza.owl")
onto.load()

"""The URL of the pizza.owl is different from namespace.
So we load the correct namespace.
"""

pizza = onto.get_namespace('http://www.co-ode.org/ontologies/pizza/pizza.owl')

"""Then we start the reasoner to build missing relations"""

sync_reasoner()

"""Show all defined classes:"""

list(onto.classes())

"""All properties"""

list(onto.properties())

"""## Ex1:Show list of pizzas that have fish topping

Create set of fishToppings and its' descendants
"""

fishToppingList=set(pizza.FishTopping.descendants())
fishToppingList

"""Display pizzas which have **hasTopping** property"""

[x for x in onto.classes() if x.hasTopping]

"""Show classes that have fish toppings"""

[x for x in onto.classes() if x.hasTopping and len(fishToppingList.intersection(set(x.hasTopping)))>0]

"""## Ex2: Show pizzas with vegetable toppings

Explore class names (pizza.OliveTopping is one of VegetableTopping)
"""

pizza.OliveTopping.is_a

"""Create a set of vegetable toppings"""

vegetableToppingList=set(pizza.VegetableTopping.descendants())
vegetableToppingList

"""Show classes that have vegetable toppings"""

[x for x in onto.classes() if x.hasTopping and len(vegetableToppingList.intersection(set(x.hasTopping)))>0]

"""## Ex3: Show pizzas with Hot spiciness

Explore structure
"""

pizza.Spiciness.descendants()

pizza.CajunSpiceTopping.hasSpiciness

pizza.CajunSpiceTopping.is_a

pizza.SpicyTopping.descendants()

"""Filter SpicyToppings"""

spicyToppings={x for x in pizza.SpicyTopping.descendants() if x.hasSpiciness and x.hasSpiciness==pizza.Hot}

spicyToppings

"""Select pizzas having spicy toppings"""

[x for x in pizza.NamedPizza.descendants() if x.hasTopping and len(spicyToppings.intersection(set(x.hasTopping)))>0]

"""Another way to select. Use the 
`pizza.SpicyPizza`
class
"""

set(pizza.SpicyPizza.descendants()).intersection(pizza.NamedPizza.descendants())

"""## Ex4: Show pizzas having 2 or more cheeses in toppings

Do some exploration
"""

pizza.CheeseTopping.descendants()

"""Compose list of desired toppings"""

cheeseToppings={x for x in pizza.CheeseTopping.descendants()}
cheeseToppings

"""Select pizzas (pizza.FourCheesesTopping is special case)"""

[x 
    for x in pizza.NamedPizza.descendants() 
    if x.hasTopping 
       and ( len(cheeseToppings.intersection(set(x.hasTopping)))>=2 or pizza.FourCheesesTopping in x.hasTopping)
]

"""## Ex5: Group pizzas by country"""

[(x.hasCountryOfOrigin,x) for x in onto.classes() if x.hasCountryOfOrigin]

tmp=[(x.hasCountryOfOrigin[0],x) for x in onto.classes() if x.hasCountryOfOrigin]

by_country={}
for c,p in tmp:
  if c not in by_country:
    by_country[c]=[]
  by_country[c].append(p)
by_country

"""## Ex6: Show ingrediends of a given pizza"""

given_pizza=pizza.American

for t in given_pizza.hasTopping:
  print(t)
  print(t.)

given_pizza.hasBase

"""## Ex7: Search pizza by topping"""

the_topping = pizza.MushroomTopping

[x for x in onto.classes() if x.hasTopping and the_topping in x.hasTopping]

"""## Ex8: Show toppings grouped by types"""

list(pizza.PizzaTopping.subclasses())

for x in list(pizza.PizzaTopping.subclasses()):
  print(x)
  print(x.descendants())

"""## Ex9: Show pizzas that don't have a given topping"""

prohibited_topping=pizza.FishTopping

[x 
    for x in pizza.NamedPizza.descendants() 
    if x.hasTopping 
       and ( prohibited_topping not in x.hasTopping)
]

"""## Ex10: Show existing ingredient pairs and their frequency"""

pizzas=[x 
    for x in onto.classes() 
    if x.hasTopping
]

pairs=dict()
for x in pizzas:
  t=list(x.hasTopping)
  for i in range(0, len(t)):
    for j in range(i+1, len(t)):
      try:
        key='+'.join(sorted([t[i].name, t[j].name]))
        if key in pairs:
          pairs[key] +=1
        else:
          pairs[key] =1
      except:
        pass

for k in pairs:
  print( (k, pairs[k]) )

"""#TODO"""

t[3].name

2.12) Сформувати меню (назва піцци, рівень гостроти, країна походження, склад)
2.13) Сформувати вегетаріанське меню (назва піцци, рівень гостроти, країна походження, склад)
2.14) Підрахувати кількість різновидів піцци для кожного із видів начинки